
init([URL, Type, Options]) ->
  Host = proplists:get_value(host, Options),
  LifeTimeout = proplists:get_value(life_timeout, Options, ?FILE_CACHE_TIME),
  Filter = proplists:get_value(filter, Options),
  Timeshift = proplists:get_value(timeshift, Options),
  TimeshiftModule = proplists:get_value(timeshift_module, Options, array_timeshift),
  Shift = case Timeshift of
    undefined -> undefined;
    Timeshift -> 
      ?D({"Initializing timeshift", TimeshiftModule, Timeshift}),
      TimeshiftModule:init(Options)
  end,
  Device = case Type of
    record ->
    _ -> 
      undefined
  end,
  
  Media = init(#media_info{host = Host, name = URL, type = Type, life_timeout = LifeTimeout, filter = Filter, 
                           timeshift = Timeshift, shift = Shift, timeshift_module = TimeshiftModule, device = Device,
                           options = Options}),
  {ok, Media, ?TIMEOUT};

init(#media_info{type = rtmp, name = URL} = Media) ->
  {rtmp, _UserInfo, Host, Port, _Path, _Query} = http_uri2:parse(URL),
  {ok, Socket} = gen_tcp:connect(Host, Port, [binary, {active, false}, {packet, raw}]),
  {ok, RTMP} = rtmp_socket:connect(Socket),
  Media#media_info{socket = Socket, demuxer = RTMP};

init(#media_info{type = mpegts_file, name = Name, host = Host} = Media) ->
  FileName = filename:join([file_media:file_dir(Host), Name]), 
  {ok, Reader} = ems_sup:start_mpegts_file_reader(FileName, [{consumer,self()}]),
  link(Reader),
  Media#media_info{demuxer = Reader};


init(#media_info{type = mpegts_passive} = Media) ->
  {ok, Reader} = ems_sup:start_mpegts_reader(self()),
  Media#media_info{demuxer = Reader};

init(#media_info{type = shoutcast, options = Options} = Media) ->
  Sock = case proplists:get_value(make_request, Options, true) of
    true -> connect_http(Media);
    _ -> undefined
  end,
  {ok, Reader} = ems_sup:start_shoutcast_reader(self()),
  Media#media_info{socket = Sock, demuxer = Reader};
  

init(#media_info{type = rtsp} = Media) ->
  connect_rtsp(Media);
  

init(#media_info{options = Options} = Media) ->
  Owner = proplists:get_value(owner, Options),
  case Owner of
    undefined -> ok;
    _ -> erlang:monitor(process, Owner)
  end,
	Media#media_info{owner = Owner}.


print_state(#media_info{} = MediaInfo) ->
  MediaInfo#media_info{shift = hidden_timeshift}.


%%-------------------------------------------------------------------------
%% @spec (Request, From, State) -> {reply, Reply, State}          |
%%                                 {reply, Reply, State, Timeout} |
%%                                 {noreply, State}               |
%%                                 {noreply, State, Timeout}      |
%%                                 {stop, Reason, Reply, State}   |
%%                                 {stop, Reason, State}
%% @doc Callback for synchronous server calls.  If `{stop, ...}' tuple
%%      is returned, the server is stopped and `terminate/2' is called.
%% @end
%% @private
%%-------------------------------------------------------------------------


handle_call({set_socket, Socket}, _From, #media_info{mode = Mode} = State) ->
  inet:setopts(Socket, [{active, once}, {packet, raw}]),
  ?D({"Stream received socket in mode", Mode}),
  {reply, ok, State#media_info{socket = Socket}, ?TIMEOUT};

handle_call(Request, _From, State) ->
  ?D({"Undefined call", Request, _From, State}),
  {stop, {unknown_call, Request}, State}.



%%-------------------------------------------------------------------------
%% @spec (Msg, State) ->{noreply, State}          |
%%                      {noreply, State, Timeout} |
%%                      {stop, Reason, State}
%% @doc Callback for asyncrous server calls.  If `{stop, ...}' tuple
%%      is returned, the server is stopped and `terminate/2' is called.
%% @end
%% @private
%%-------------------------------------------------------------------------
handle_cast(_Msg, State) ->
  ?D({"Undefined cast", _Msg}),
  {noreply, State, ?TIMEOUT}.

%%-------------------------------------------------------------------------
%% @spec (Msg, State) ->{noreply, State}          |
%%                      {noreply, State, Timeout} |
%%                      {stop, Reason, State}
%% @doc Callback for messages sent directly to server's mailbox.
%%      If `{stop, ...}' tuple is returned, the server is stopped and
%%      `terminate/2' is called.
%% @end
%% @private
%%-------------------------------------------------------------------------


handle_info(graceful, #media_info{type = mpegts_passive, clients = []} = MediaInfo)  ->
  ?D({self(), "No clients for pushed MPEG-TS, still living", MediaInfo#media_info.name}),
  {noreply, MediaInfo, ?TIMEOUT};

handle_info(graceful, #media_info{life_timeout = false} = MediaInfo) ->
  ?D({self(), "No readers for stream, but ever life", MediaInfo#media_info.name}),
  {stop, normal, MediaInfo};

handle_info(graceful, #media_info{owner = undefined, clients = []} = MediaInfo) ->
  ?D({self(), "No readers and owner for stream, stopping", MediaInfo#media_info.name}),
  {stop, normal, MediaInfo};

handle_info(graceful, #media_info{owner = undefined} = MediaInfo) ->
  ?D({self(), "Graceful no owner, but have readers", length(MediaInfo#media_info.clients)}),
  {noreply, MediaInfo, ?TIMEOUT};

handle_info(graceful, #media_info{owner = _Owner} = MediaInfo) ->
  ?D({self(), "Graceful", _Owner}),
  {noreply, MediaInfo, ?TIMEOUT};
  
handle_info({'DOWN', _Ref, process, Owner, _Reason}, #media_info{owner = Owner, life_timeout = LifeTimeout} = MediaInfo) ->
  ems_event:stream_source_lost(MediaInfo#media_info.host, MediaInfo#media_info.name, self()),
  case LifeTimeout of
    false ->
      ?D({MediaInfo#media_info.name, "Owner exits, we don't"}),
      {noreply, MediaInfo#media_info{owner = undefined}, ?TIMEOUT};
    _ ->
      timer:send_after(LifeTimeout, graceful),
      % ?D({MediaInfo#media_info.name, "Owner exits, wait him", LifeTimeout}),
      {noreply, MediaInfo#media_info{owner = undefined}, ?TIMEOUT}
  end;

handle_info({'DOWN', _Ref, process, Demuxer, _Reason}, #media_info{type = rtsp, demuxer = Demuxer} = Media) ->
  {noreply, connect_rtsp(Media), ?TIMEOUT};




handle_info(#video_frame{} = Frame, #media_info{} = Recorder) ->
  {noreply, handle_frame(Frame, Recorder), ?TIMEOUT};


handle_info({filter, Module, Message}, #media_info{filter = {Module, State}} = Recorder) ->
  State1 = Module:handle_message(State, Recorder, Message),
  {noreply, Recorder#media_info{filter = {Module, State1}}, ?TIMEOUT};

handle_info(start, State) ->
  {noreply, State, ?TIMEOUT};

handle_info(stop, #media_info{type = live} = MediaInfo) ->
  {noreply, MediaInfo, ?TIMEOUT};

handle_info(stop, #media_info{host = Host, name = Name} = MediaInfo) ->
  media_provider:remove(Host, Name),
  {noreply, MediaInfo, ?TIMEOUT};

handle_info(exit, State) ->
  {stop, normal, State};

handle_info(timeout, #media_info{type = rtsp, life_timeout = false} = Media) ->
  {noreply, connect_rtsp(Media)};

handle_info(timeout, #media_info{type = Type, life_timeout = LifeTimeout} = State) when (Type == live orelse Type == mpegts_passive) andalso LifeTimeout =/= false ->
  {stop, normal, State};

handle_info(pause, State) ->
  {noreply, State, ?TIMEOUT};

handle_info(resume, State) ->
  {noreply, State, ?TIMEOUT};
  
handle_info({client_buffer, _Buffer}, State) ->
  {noreply, State, ?TIMEOUT};

handle_info(clean_timeshift, #media_info{timeshift = Timeshift, timeshift_module = Module} = MediaInfo) when is_number(Timeshift) andalso Timeshift > 0 ->
  {noreply, Module:clean(MediaInfo), ?TIMEOUT};
  
handle_info(clean_timeshift, MediaInfo) ->
  {noreply, MediaInfo, ?TIMEOUT};

handle_info({rtmp, RTMP, connected}, #media_info{name = URL} = State) ->
  ?D({"Connected to RTMP source", URL}),
  {rtmp, _UserInfo, _Host, _Port, FullPath, _Query} = http_uri2:parse(URL),
  [App|PathParts] = string:tokens(FullPath, "/"),
  Path = list_to_binary(string:join(PathParts, "/")),
  ?D({"App,path", App, Path}),
  rtmp_socket:setopts(RTMP, [{active, true}]),
  rtmp_lib:connect(RTMP, [{app, list_to_binary(App)}, {tcUrl, list_to_binary(URL)}]),
  ?D("Connected"),
  Stream = rtmp_lib:createStream(RTMP),
  ?D({"Stream",Stream}),
  rtmp_lib:play(RTMP, Stream, Path),
  ?D({"Playing", Path}),
  {noreply, State, ?TIMEOUT};

handle_info({rtmp, _RTMP, #rtmp_message{type = Type, timestamp = Timestamp, body = Body} = Message}, Recorder) when Type == audio orelse Type == video ->
  Frame = flv_video_frame:decode(#video_frame{dts = Timestamp, pts = Timestamp, type = Type}, Body),
  % ?D({Frame#video_frame.codec_id, Frame#video_frame.frame_type, Frame#video_frame.decoder_config, Message#rtmp_message.timestamp}),
  {noreply, handle_frame(Frame, Recorder), ?TIMEOUT};

handle_info({rtmp, _RTMP, #rtmp_message{type = metadata, timestamp = Timestamp, body = [<<"onMetaData">>, {object, Meta}]}}, Recorder)  ->
  ?D(Meta),
  % ?D({Frame#video_frame.codec_id, Frame#video_frame.frame_type, Frame#video_frame.decoder_config, Message#rtmp_message.timestamp}),
  Frame = #video_frame{type = metadata, dts = Timestamp, pts = Timestamp, body = Meta},
  {noreply, handle_frame(Frame, Recorder), ?TIMEOUT};

handle_info({rtmp, _RTMP, #rtmp_message{} = Message}, State) ->
  ?D({"RTMP message", Message}),
  {noreply, State, ?TIMEOUT};

handle_info(Message, State) ->
  {stop, {unhandled, Message}, State}.





%%%%%%%%%%%%%%%%%%        Frame handling         %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


send_client_frame({Client, _}, Frame) ->
  Client ! Frame.

send_frame(Frame, #media_info{clients = Clients}) ->
  % ?D({Frame#video_frame.type, Frame#video_frame.frame_type, Frame#video_frame.decoder_config, Frame#video_frame.dts}),
  lists:foldl(fun send_client_frame/2, Frame, Clients).
  
  
pass_through_filter(#video_frame{} = Frame, #media_info{filter = undefined} = Recorder) ->
  {Frame, Recorder};

pass_through_filter(#video_frame{} = Frame, #media_info{filter = {Module, State}} = Recorder) ->
  {ok, State1, Frame1} = Module:handle_frame(State, Recorder, Frame),
  {Frame1, Recorder#media_info{filter = {Module, State1}}}.

store_last_gop(MediaInfo, #video_frame{type = video, frame_type = keyframe} = Frame) ->
  ?D({"New GOP", round((Frame#video_frame.dts)/1000)}),
  MediaInfo#media_info{gop = [Frame]};

store_last_gop(#media_info{gop = GOP} = MediaInfo, _) when length(GOP) == 5000 ->
  ?D({"GOP longer than 5000 frames"}),
  MediaInfo#media_info{gop = []};

store_last_gop(#media_info{gop = GOP} = MediaInfo, Frame) when is_list(GOP) ->
  MediaInfo#media_info{gop = [Frame | GOP]};

  
store_last_gop(MediaInfo, _) ->
  MediaInfo.


copy_audio_config(MediaInfo, #video_frame{decoder_config = true, type = audio} = Frame) ->
  MediaInfo#media_info{audio_config = Frame#video_frame{dts = 0, pts = 0}};

copy_audio_config(MediaInfo, _) -> MediaInfo.

copy_video_config(MediaInfo, #video_frame{decoder_config = true, type = video} = Frame) ->
  % ?D({"Video config", Frame}),
  Metadata = h264:metadata(Frame#video_frame.body),
  send_frame(Metadata, MediaInfo),
  MediaInfo#media_info{video_config = Frame#video_frame{dts = 0, pts = 0}, metadata = Metadata};

copy_video_config(MediaInfo, _) -> MediaInfo.


parse_metadata(MediaInfo, #video_frame{type = metadata, body = Metadata}) ->
  parse_metadata(MediaInfo, Metadata);

parse_metadata(MediaInfo, #video_frame{}) ->
  MediaInfo;
  
parse_metadata(MediaInfo, undefined) ->
  MediaInfo;
  
parse_metadata(MediaInfo, [{object, Metadata}]) ->
  % ?D({"Metadata", Metadata}),
  set_metadata(MediaInfo, Metadata);

parse_metadata(MediaInfo, [_|Metadata]) -> parse_metadata(MediaInfo, Metadata);
parse_metadata(MediaInfo, []) -> MediaInfo.

set_metadata(MediaInfo, [{framerate, Rate} | Metadata]) ->
  set_metadata(MediaInfo#media_info{framerate = Rate}, Metadata);

set_metadata(MediaInfo, [{width, Width} | Metadata]) ->
  set_metadata(MediaInfo#media_info{width = round(Width)}, Metadata);

set_metadata(MediaInfo, [{height, Height} | Metadata]) ->
  set_metadata(MediaInfo#media_info{height = round(Height)}, Metadata);

set_metadata(MediaInfo, [{videocodecid, VideoCodec} | Metadata]) ->
  set_metadata(MediaInfo#media_info{video_codec = video_codec(VideoCodec)}, Metadata);

set_metadata(MediaInfo, [{audiocodecid, AudioCodec} | Metadata]) ->
  set_metadata(MediaInfo#media_info{audio_codec = audio_codec(AudioCodec)}, Metadata);

set_metadata(MediaInfo, [{_Key, _Value} | Metadata]) ->
  % ?D({_Key, _Value}),
  set_metadata(MediaInfo, Metadata);

set_metadata(MediaInfo, []) -> MediaInfo.

video_codec(<<"avc1">>) -> h264;
video_codec(<<"VP62">>) -> vp6.


audio_codec(<<"mp4a">>) -> aac;
audio_codec(<<"nmos">>) -> nelly_moser;
audio_codec(<<".mp3">>) -> mp3.

%%-------------------------------------------------------------------------
%% @spec (Reason, State) -> any
%% @doc  Callback executed on server shutdown. It is only invoked if
%%       `process_flag(trap_exit, true)' is set by the server process.
%%       The return value is ignored.
%% @end
%% @private
%%-------------------------------------------------------------------------
terminate(_Reason, #media_info{device = Device, host = Host, name = URL} = _MediaInfo) ->
  (catch file:close(Device)),
  ems_event:stream_stopped(Host, URL, self()),
  ok.

%%-------------------------------------------------------------------------
%% @spec (OldVsn, State, Extra) -> {ok, NewState}
%% @doc  Convert process state when code is changed.
%% @end
%% @private
%%-------------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) ->
  {ok, State}.

